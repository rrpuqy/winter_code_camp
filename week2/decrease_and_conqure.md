# 减而治之 笔记

## 堆的例子

- 堆的特性 堆顶元素最大

-  每一颗子树中 根节点大于左右孩子节点

### 堆的主要操作

- 建堆
- 插入新元素 
- 出堆

最主要的部分就是自底向上进行更新 和出队时自顶向下更新

以自底向上更新为例 可以看成是一个减而治之的过程 

不断与父元素进行对比 如果比父元素大则与父元素交换位置 

然后在新的位置上重复这种过程 直到比父元素小或者到达根节点


>分治和减治的共同点是都会将问题分为至少两个子问题，区别在于，分治需要对于每个子问题都进行递归求解，而减治只需要对于其中一部分子问题递归求解，剩余的子问题可以较为平凡地直接求解。

>减治举例：如线性递归，规模为 n 的问题分为规模分别为 n-1 和 1 的两个子问题，规模为 1 的问题可以立刻算出，规模为 n-1 的问题当作是同类问题，递归求解。问题分为了两部分，但只递归了一次。

>分治举例：二分递归，将规模为 n 的问题分为规模为 n/2 的两个子问题，对于两个子问题都递归求解。递归次数与子问题数目相等。

我个人的理解是减而治之 是将原问题划分为更小的子问题，直至可以平凡的求解，通过相同的算法将问题的规模不断的减少。

### 例如二分查找的例子

```c++
int binary_search(int e,int lo,int hi){
    while(lo<hi){ // 始终保持[0,lo)<=e<[hi,)
        rank mid = (lo+hi)/2;
        e<a[mid]?hi=mid:lo=mid+1; [lo,mi),(mi,hi)
    }
    return --lo;
}
```

### 寻找众数的例子 

这里面的众数是在所有数中占一半以上的数
- 如果向量A有众数m 
- 若存在前缀P P的长度为偶数 且m出现的次数为p的长度的一半
- 当且仅当向量A-P有众数m。

所以我们需要构造使得m占一半的前缀p

即扫描序列 碰见m使得计数器加一 碰见非m使得计数器减一


如果众数包含恰好占一半的数呢？

如果计数器最终为0

记录最后一个使计数器变零的数 和之前的众数候选者 判断他们两个是否是众数 

最后一个使得计数器清零的数 就是序列中最后一个元素
之前的众数候选者就是返回的majority 

```c++
int find_maj(vector<int> a){
    int c = 0;
    int maj;
    for(int i=0;i<a.size();i++){
        if(c==0){
            maj = a[i];
            c = 1;
        }
        else{
            if(a[i] == maj) c++;
            else c--;
        }
    }
    return maj;
}